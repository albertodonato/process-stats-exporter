#!/usr/bin/env python

from collections import namedtuple
from itertools import chain

from prometheus_aioexporter.script import PrometheusExporterScript
from prometheus_aioexporter.metric import MetricConfig

from lxstats.process import (
    Collection,
    Collector,
    CommandLineFilter)


Stat = namedtuple('Stat', ['name', 'description', 'metric', 'type'])

STATS = (
    Stat(
        'stat.utime', 'Time scheduled in user mode', 'process_time_user',
        'counter'),
    Stat(
        'stat.stime', 'Time scheduled in kernel mode', 'process_time_system',
        'counter'),
    Stat(
        'stat.rss', 'Memory resident segment size (RSS)',
        'process_mem_rss', 'gauge'),
    Stat(
        'stat.majflt', 'Number of major faults that required a page load',
        'process_maj_fault', 'counter'),
    Stat(
        'stat.minflt', 'Number of minor faults the not required a page load',
        'process_min_fault', 'counter'),
    Stat(
        'sched.nr_involuntary_switches',
        'Number of involuntary context switches',
        'process_ctx_involuntary', 'counter'),
    Stat(
        'sched.nr_voluntary_switches', 'Number of voluntary context switches',
        'process_ctx_voluntary', 'counter'),
    Stat(
        'status.VmHWM', 'Maximum memory resident segment size (RSS)',
        'process_mem_rss_max', 'counter'))


class ProcessStatsExporter(PrometheusExporterScript):
    """Prometheus exporter script for process statistics."""

    name = 'process-stats-exporter'

    def configure_argument_parser(self, parser):
        parser.add_argument(
            '-i', '--interval', type=int, default=10,
            help='stats update interval')
        parser.add_argument(
            '-P', '--pids', nargs='+', type=int, metavar='pid',
            help='process PID')
        parser.add_argument(
            '-R', '--name-regexps', nargs='+',
            metavar='name-regexp', help='regexp to match process name')

    def configure(self, args):
        self.pids = args.pids
        self.name_regexps = args.name_regexps
        if self.pids:
            self.logger.info(
                'tracking stats for PIDs [{}]'.format(', '.join(self.pids)))
        elif self.name_regexps:
            self.logger.info(
                'tracking stats for processes [{}]'.format(
                    ', '.join(self.name_regexps)))
        else:
            self.logger.warning('no process to track')

        self.create_metrics(
            MetricConfig(
                stat.metric, stat.description, stat.type, {'labels': ['cmd']})
            for stat in STATS)

    async def on_application_startup(self, application):
        application.set_metric_update_handler(self._update_metrics)

    def _update_metrics(self, metrics):
        for process in self._get_process_iterator():
            process.collect_stats()
            for stat in STATS:
                value = process.get(stat.name)
                if value is None:
                    self.logger.warning(
                        'emtpy value for metric "{}" on PID {}'.format(
                            stat.name, process.pid))
                    continue
                metric = metrics[stat.metric].labels(cmd=process.get('comm'))
                if stat.type == 'counter':
                    metric.inc(value)
                elif stat.type == 'gauge':
                    metric.set(value)

    def _get_process_iterator(self):
        if self.pids:
            return Collection(collector=Collector(pids=self.pids))
        elif self.name_regexps:
            collections = []
            for name_re in self.name_regexps:
                collection = Collection()
                collection.add_filter(CommandLineFilter(name_re))
                collections.append(collection)
            return chain(*collections)
        else:
            return iter(())


if __name__ == '__main__':
    ProcessStatsExporter()()
